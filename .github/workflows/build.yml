name: Application Build

on:
  workflow_dispatch: 
  pull_request:

jobs:
  linux-build:
    uses: ./.github/workflows/linux-build.yml
    with:
      build_number: ${{ github.run_number }}
      prebuilds_only: "1"
    secrets:
      APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
      APPLE_TEAM_PREFIX: ${{ secrets.APPLE_TEAM_PREFIX }}

  windows-build:
    uses: ./.github/workflows/windows-build.yml
    with:
      build_number: ${{ github.run_number }}
      prebuilds_only: "1"
    secrets:
      APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
      APPLE_TEAM_PREFIX: ${{ secrets.APPLE_TEAM_PREFIX }}

  macos-build:
    uses: ./.github/workflows/macos-build.yml
    with:
      build_number: ${{ github.run_number }}
      prebuilds_only: "1"
    secrets:
      APPLE_MAC_CERT: ${{ secrets.APPLE_MAC_CERT }}
      APPLE_MAC_CERT_PASS: ${{ secrets.APPLE_MAC_CERT_PASS }}
      APPLE_KEYCHAIN: ${{ secrets.APPLE_KEYCHAIN }}
      APPLE_KEYCHAIN_PASS: ${{ secrets.APPLE_KEYCHAIN_PASS }}
      APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
      APPLE_TEAM_PREFIX: ${{ secrets.APPLE_TEAM_PREFIX }}
      APPLE_DEVELOPER_ID_APPLICATION: ${{ secrets.APPLE_DEVELOPER_ID_APPLICATION }}
      APPLE_DEVELOPER_ID_INSTALLER: ${{ secrets.APPLE_DEVELOPER_ID_INSTALLER }}
      APPLE_MAS_IDENTITY: ${{ secrets.APPLE_MAS_IDENTITY }}
      APPLE_MAS_INSTALLER_IDENTITY: ${{ secrets.APPLE_MAS_INSTALLER_IDENTITY }}
      APPLE_PROVISIONING_PROFILE: ${{ secrets.APPLE_PROVISIONING_PROFILE }}

  map-rpm:
    needs: linux-build

    strategy:
      matrix:
        os:
          [
            "ubuntu-22.04",
            "ubuntu-24.04",
            "ubuntu-24.04-arm",
          ]
        arch: ["x64", "arm64"]
        docker: [
          "fedora:latest",
          "opensuse/leap:latest",
          "opensuse/tumbleweed:latest",
          "rockylinux:9.3",
          "rockylinux:8.9",
          "almalinux:latest",
          "redhat/ubi8:latest",
          "redhat/ubi9:latest",
          ]
        exclude:
          - os: "ubuntu-22.04"
            arch: "arm64"
          - os: "ubuntu-24.04-arm"
            arch: "x64"
          - os: "ubuntu-24.04"
            arch: "arm64"
          - os: "ubuntu-24.04-arm"
            docker: "fedora:latest"
          - os: "ubuntu-24.04-arm"
            docker: "opensuse/leap:latest"
          - os: "ubuntu-24.04-arm"
            docker: "opensuse/tumbleweed:latest"
          - os: "ubuntu-24.04-arm"
            docker: "rockylinux:9.3"
          - os: "ubuntu-24.04-arm"
            docker: "rockylinux:8.9"
          - os: "ubuntu-24.04-arm"
            docker: "almalinux:latest"
          - os: "ubuntu-24.04-arm"
            docker: "redhat/ubi8:latest"
          - os: "ubuntu-24.04-arm"
            docker: "redhat/ubi9:latest"
          - os: "ubuntu-22.04"
            docker: "fedora:latest"
          - os: "ubuntu-22.04"
            docker: "opensuse/leap:latest"
          - os: "ubuntu-22.04"
            docker: "opensuse/tumbleweed:latest"
          - os: "ubuntu-22.04"
            docker: "rockylinux:9.3"
          - os: "ubuntu-22.04"
            docker: "rockylinux:8.9"
          - os: "ubuntu-22.04"
            docker: "almalinux:latest"
          - os: "ubuntu-22.04"
            docker: "redhat/ubi8:latest"
          - os: "ubuntu-22.04"
            docker: "redhat/ubi9:latest"
      fail-fast: true

    runs-on: ${{ matrix.os }}
    container:
      image: ${{ matrix.docker }}

    steps:
      - name: Download Debian-artifacts
        uses: actions/download-artifact@v4
        with:
          name: debian-dependencies-${{ matrix.os }}-${{ matrix.arch }}
          path: .

      - name: Check downloaded artifacts
        run: |
          echo "Listing all downloaded files:"
          ls -la
          echo "Content of so-deps.txt file (if exists):"
          if [ -f "so-deps.txt" ]; then
            cat so-deps.txt
          else
            echo "so-deps.txt does not exist!"
            echo "# Empty file - no dependencies found" > so-deps.txt
          fi

      - name: Install query tools & awk (distro-agnostisch)
        run: |
          echo "DOCKER_LABEL=$(echo '${{ matrix.docker }}' | tr ':/' '_')" >> $GITHUB_ENV
          if   command -v dnf    >/dev/null; then
            echo "Detected dnf → installing dnf-plugins-core and gawk"
            dnf install -y dnf-plugins-core gawk
          elif command -v yum    >/dev/null; then
            echo "Detected yum → installing yum-utils and gawk"
            yum install -y yum-utils gawk
          elif command -v zypper >/dev/null; then
            echo "Detected zypper → refreshing repos"
            zypper refresh
            
            # Additional tools for zypper package querying
            echo "Installing query tools for OpenSUSE"
            zypper install -y gawk grep
          else
            echo "No supported package manager found, assuming awk is present"
          fi
  
      - name: Map SONAME → RPM-Paket (inkl. generische .so)
        run: |
          echo "# RPM-Abhängigkeiten pro SONAME (inkl. generischer .so)" > rpm-deps-detail.txt
          rpm_list=()
          
          if [ ! -f "so-deps.txt" ]; then
            echo "WARNING: so-deps.txt file not found, creating empty file"
            echo "# Empty file - no dependencies found" > so-deps.txt
            echo "Requires: " > rpm-deps.txt
            exit 0
          fi
          
          # Check if so-deps.txt has content with proper format
          if ! grep -q -- "->" so-deps.txt; then
            echo "WARNING: so-deps.txt does not contain expected format with '->' symbols"
            echo "Content of so-deps.txt:"
            cat so-deps.txt
            echo "Creating empty dependency files"
            echo "Requires: " > rpm-deps.txt
            exit 0
          fi
          
          # Extract SONAME list - with additional error handling
          sos=$(grep -- '->' so-deps.txt | cut -d ' ' -f1 | sort -u) || true
          if [ -z "$sos" ]; then
            echo "WARNING: No shared object names found in so-deps.txt"
            echo "Requires: " > rpm-deps.txt
            exit 0
          fi
          echo "Found shared objects to process:"
          echo "$sos"
          
          # Detect if this is an openSUSE distribution
          is_opensuse=0
          if command -v zypper >/dev/null; then
            is_opensuse=1
            echo "Detected openSUSE distribution, using special package search logic"
          fi

          # Query-Befehl wählen for non-openSUSE distributions
          if   command -v dnf    >/dev/null && [ $is_opensuse -eq 0 ]; then 
            QUERY="dnf repoquery --quiet --whatprovides"
          elif command -v yum    >/dev/null && [ $is_opensuse -eq 0 ]; then 
            QUERY="yum whatprovides"
          elif [ $is_opensuse -eq 0 ]; then
            QUERY="rpm -q --whatprovides"
          fi

          # Process each SONAME and find providing packages
          for so in $sos; do
            echo "## $so" >> rpm-deps-detail.txt
            pkg_full=""
            pkg_base=""

            if [ $is_opensuse -eq 1 ]; then
              # Simple direct query for OpenSUSE using zypper se --provides --match-exact
              echo "Looking up package for $so using zypper se --provides --match-exact"
              
              # Use match-exact for precise library name lookup
              search_result=$(zypper se --provides --match-exact "$so" 2>/dev/null) || true
              
              if [ -n "$search_result" ] && ! echo "$search_result" | grep -q "No matching items found"; then
                # Extract package name - skip header lines and take first match
                pkg_full=$(echo "$search_result" | grep -E "^[i | ]" | grep -v "32bit" | sort -r | head -n1 | awk '{print $2}')
                echo "  Found package via zypper se --provides --match-exact: $pkg_full"
              else
                echo "  Direct search failed, trying base name pattern"
                # If direct search fails, try with the base library name (without version)
                base_name=$(echo "$so" | sed -E 's/^(lib[^.]+).*$/\1/' | tr '[:upper:]' '[:lower:]')
                if [ -n "$base_name" ]; then
                  # Try to find a package that begins with the base name
                  search_result=$(zypper se -s "${base_name}*" 2>/dev/null) || true
                  
                  if [ -n "$search_result" ] && ! echo "$search_result" | grep -q "No matching items found"; then
                    # Extract the most relevant package name
                    pkg_full=$(echo "$search_result" | grep -E "^[i | ]" | grep -i "$base_name" | grep -v "32bit" | sort -r | head -n1 | awk '{print $2}')
                    echo "  Found package via pattern search: $pkg_full"
                  else
                    echo "  No package found for $so"
                    pkg_full="not-found"
                  fi
                fi
              fi
            else
              # Existing code for other distributions
              pkg_full=$($QUERY "*$so" 2>/dev/null | head -n1) || true
              echo "  Package for $so: $pkg_full"
            fi
            
            echo "$so => $pkg_full" >> rpm-deps-detail.txt
            if [ -n "$pkg_full" ] && [ "$pkg_full" != "not-found" ]; then
              rpm_list+=("$pkg_full")
            fi

            # Generischen Symlink (libname.so)
            base=$(echo "$so" | sed -E 's/(.*\.so)\..+/\1/' 2>/dev/null) || true
            if [ -n "$base" ] && [[ "$base" != "$so" ]]; then
              if [ $is_opensuse -eq 1 ]; then
                # Simple direct query for the base library using match-exact
                search_result=$(zypper se --provides --match-exact "$base" 2>/dev/null) || true
                
                if [ -n "$search_result" ] && ! echo "$search_result" | grep -q "No matching items found"; then
                  pkg_base=$(echo "$search_result" | grep -E "^[i | ]" | grep -v "32bit" | sort -r | head -n1 | awk '{print $2}')
                  echo "  Found base package via zypper se --provides --match-exact: $pkg_base"
                else
                  # If not found, use the same package as the versioned library
                  pkg_base="$pkg_full"
                  echo "  Using same package for base library $base: $pkg_base"
                fi
              else
                # Existing code for other distributions
                pkg_base=$($QUERY "*$base" 2>/dev/null | head -n1) || true
                echo "  Package for base $base: $pkg_base"
              fi
              
              echo "$base => $pkg_base" >> rpm-deps-detail.txt
              if [ -n "$pkg_base" ] && [ "$pkg_base" != "not-found" ]; then
                rpm_list+=("$pkg_base")
              fi
            fi

            echo "" >> rpm-deps-detail.txt
          done

          # Show found packages for debugging
          echo "Found packages:"
          if [ ${#rpm_list[@]} -eq 0 ]; then
            echo "  No packages found!"
          else
            printf "  %s\n" "${rpm_list[@]}" | sort -u
          fi
          
          # Kommagetrennte Requires-Zeile
          if [ ${#rpm_list[@]} -eq 0 ]; then
            echo "Warning: No packages found, creating empty requires"
            echo "Requires: " > rpm-deps.txt
          else
            # The following is safer - create the file first in case paste fails
            printf "%s\n" "${rpm_list[@]}" | sort -u | grep -v "^$" > /tmp/pkg_list
            if [ -s /tmp/pkg_list ]; then
              # File has content, create comma-separated list
              uniq_pkgs=$(paste -sd ', ' /tmp/pkg_list)
              echo "Requires: $uniq_pkgs" > rpm-deps.txt
            else
              # File is empty
              echo "Requires: " > rpm-deps.txt
            fi
          fi
          
          # Ensure the detail file exists even if empty
          touch rpm-deps-detail.txt

      - name: Show generated files
        run: |
          echo "Content of rpm-deps.txt:"
          cat rpm-deps.txt
          echo "--------------------------"
          echo "Content of rpm-deps-detail.txt (first 20 lines):"
          head -n 20 rpm-deps-detail.txt
          echo "--------------------------"

      - name: Upload RPM-mapping artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpm-dependencies-${{ env.DOCKER_LABEL }}
          retention-days: 1
          path: |
            rpm-deps.txt
            rpm-deps-detail.txt